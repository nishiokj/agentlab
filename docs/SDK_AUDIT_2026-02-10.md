# SDK Audit Findings (2026-02-10)

Scope: AgentLab repository (library repo), evaluated as both provider-facing API and consumer-facing usability.

## Executive Summary

The library is currently CLI-first with reusable lower-level primitives, but it does not provide a first-class programmatic SDK for authoring experiments. Documentation describes a builder-style SDK direction that is not yet implemented in the shipped public API.

## Findings (Ordered by Severity)

## 1) Critical: No First-Class SDK for Programmatic Experiment Authoring

- Packaging exports CLI entrypoints only:
  - `pyproject.toml:19`
  - `pyproject.toml:20`
  - `pyproject.toml:21`
- Public Python exports are runner primitives, not a canonical experiment model/builder:
  - `src/agentlab_runner/__init__.py:17`
  - `src/agentlab_runner/__init__.py:41`
- Rust workspace has no dedicated SDK crate; current crates are runtime/CLI oriented:
  - `rust/crates/`

Impact:
- Consumers cannot rely on a stable, high-level library API for `Experiment` construction and must assemble config/glue manually.

## 2) High: `sdk_control` / `sdk_full` Exist as Labels, Not Full Operational Capability

- SDK levels are present in schema enums:
  - `schemas/harness_manifest_v1.jsonschema:11`
  - `schemas/harness_manifest_v1.jsonschema:14`
  - `schemas/trial_input_v1.jsonschema:53`
  - `schemas/trial_input_v1.jsonschema:56`
- Python runner currently emits SDK evidence as false:
  - `src/agentlab_runner/run_engine.py:235`
- Integration-level derivation supports SDK flags but runners do not populate them end-to-end:
  - `src/agentlab_runner/integration.py:22`
  - `src/agentlab_runner/integration.py:31`

Impact:
- User-facing capability taxonomy overstates maturity of SDK integration paths.

## 3) High: Python Test Suite Fails at Collection

- Running `pytest -q` fails due stale imports (`agentlab_core.schemas`):
  - `tests/test_harness_executor.py:11`
  - `tests/test_harness_manifest.py:9`
  - `tests/test_trace_ingest.py:9`

Impact:
- Baseline confidence in Python library integrity is reduced.

## 4) High: Docs Promise Builder API, Implementation Is YAML/Resolver + Runner Orchestration

- Builder API is documented as a core direction:
  - `docs/DESIGN_PRINCIPLES.md:89`
  - `docs/DESIGN_PRINCIPLES.md:113`
- Implemented resolver path is YAML-centric and CLI-harness constrained:
  - `src/agentlab_runner/experiment_resolver.py:24`
  - `src/agentlab_runner/experiment_resolver.py:50`

Impact:
- Expectation gap for consumers trying to use “SDK-style” experiment definition.

## 5) Medium: Validation of Resolved Experiment Is Minimal

- Resolved schema currently requires only `version` and `experiment.id`:
  - `schemas/resolved_experiment_v0_3.jsonschema:7`
  - `schemas/resolved_experiment_v0_3.jsonschema:19`
- Python validation adds limited checks:
  - `src/agentlab_runner/run_engine.py:69`
  - `src/agentlab_runner/run_engine.py:72`

Impact:
- Misconfigurations can pass early checks and fail later at runtime.

## 6) Medium: Capability Gaps Still Marked Best-Effort / Not Implemented

- OTLP ingest not implemented:
  - `src/agentlab_runner/trace_ingest.py:17`
  - `src/agentlab_runner/trace_ingest.py:18`
- Rust runner rejects `allowlist_enforced` network mode:
  - `rust/crates/lab-runner/src/lib.rs:1141`
  - `rust/crates/lab-runner/src/lib.rs:1143`
- Python CLI labels replay/fork as best effort:
  - `src/agentlab_cli/cli.py:336`
  - `src/agentlab_cli/cli.py:341`

Impact:
- Scientific/reproducibility guarantees vary materially by path and are easy to over-assume.

## 7) Medium: Rust Test Coverage Is Sparse Relative to Surface Area

- `cargo test -q` run showed most crates with zero tests, and one crate with 3 tests.

Impact:
- Limited automated regression protection on the Rust path.

## What the Library Is Today

- A CLI-first experiment framework (Python + Rust) with:
  - Trial contract schemas
  - Runner orchestration
  - Analysis/report outputs
  - Provenance artifacts
- It is not yet a complete “author experiments in code via stable SDK model” platform.

## Boundary Classification: Fundamental Gaps vs Consumer Glue

## Fundamental, Generalizable Library Gaps

- No canonical high-level experiment authoring SDK (`Experiment` object + builder API + serializer).
- SDK integration levels (`sdk_control`, `sdk_full`) not fully operationalized with evidence plumbing.
- Missing explicit capability/version handshake between experiment config and installed binary behavior.
- Weak resolved-experiment validation contract.
- Test suite drift and failure in Python path.

## Necessary Consumer Glue

- Harness-specific mapping from `trial_input.bindings` to actual harness runtime behavior.
- Domain-specific task sets, hypotheses, and treatment definitions.
- Repo-specific command/setup defaults.

## Validation Performed During Audit

- Python tests:
  - `pytest -q` (failed during collection with import errors listed above).
- Rust tests:
  - `cargo test -q` in `rust/` (passed; mostly zero-test crates, one crate with 3 tests).

## Recommended Next Steps

1. Restore test baseline:
- Fix stale Python test imports (`agentlab_core.schemas` -> current schema registry path).
- Make `pytest -q` green in CI.

2. Define and ship a canonical SDK surface:
- Add a dedicated SDK module/crate exposing:
  - `Experiment`
  - `VariantPlan`
  - `AnalysisPlan`
  - deterministic `to_yaml` / `to_json` serialization.

3. Align capability semantics:
- Either implement `sdk_control`/`sdk_full` end-to-end, or temporarily remove/de-emphasize them in user-facing options.

4. Tighten schema/validation:
- Strengthen `resolved_experiment_v0_3` with required structural fields beyond `version`/`experiment.id`.

5. Add end-to-end acceptance tests:
- Programmatic SDK definition -> serialized spec -> run -> variant-dependent behavior observed.

