# AgentLab Rust Implementation Spec (Parallel Track)

This document defines a Rust implementation plan for `lab` as a compiled binary, designed to coexist with the current Python prototype.

The goal is to reuse the *contract* (schemas + file layout + invariants) while incrementally migrating the runtime to Rust where it provides durable benefits: distribution, performance, OS-level enforcement, and reduced “it depends on your Python/Node env” issues.

## Guiding Principles
- **Standards-first seams:** Harness remains BYO, driven by CLI I/O (`trial_input.json` / `trial_output.json`) plus optional evidence (hooks JSONL, OTel).
- **Fail-closed guarantees:** Only claim what is observed and verifiable.
- **Portability of artifacts:** Preserve `.lab/runs/<run_id>/...` layout and schema versions.
- **Incremental migration:** Implement Rust subcommands and features in parallel; keep artifact compatibility.

## Non-Goals (Initial Rust Track)
- Re-implement full analysis/statistics stack in Rust immediately.
- Full UI/trace viewer.
- Universal cross-platform allowlist enforcement (Linux-first for allowlist).

## Repository Layout Proposal
- `rust/` (Cargo workspace)
  - `crates/lab-cli/` (binary)
  - `crates/lab-core/` (canonical JSON, hashing, artifact store, ids)
  - `crates/lab-schemas/` (embed JSON schemas as resources)
  - `crates/lab-hooks/` (hook stream parsing + invariants)
  - `crates/lab-provenance/` (attestation, debug bundle)
  - `crates/lab-runner/` (trial execution, container runner later)
  - `crates/lab-otel/` (OTLP receiver + ingestion; optional)
- Continue to keep `schemas/` as the human-editable source-of-truth; Rust embeds them at build time.

## Artifact Compatibility Contract
Rust implementation MUST emit identical file names and primary semantics:
- `.lab/runs/<run_id>/manifest.json`
- `.lab/runs/<run_id>/resolved_experiment.json`
- `.lab/runs/<run_id>/resolved_experiment.digest`
- `.lab/runs/<run_id>/trials/<trial_id>/trial_input.json`
- `.lab/runs/<run_id>/trials/<trial_id>/trial_output.json`
- `.lab/runs/<run_id>/analysis/*` (may be produced by Python in early stages)
- `.lab/runs/<run_id>/report/index.html` (optional early; can be generated by Python)
- `.lab/runs/<run_id>/attestation.json`
- `.lab/runs/<run_id>/debug_bundles/<id>.zip`

## Phase R0 — Core Primitives (lab-core)

### Deliverables
- Canonical JSON serializer:
  - stable key ordering
  - no whitespace
  - UTF-8
- SHA256 helpers
- Artifact store:
  - `artifacts/sha256/<hex>`
  - `artifact://sha256/<hex>` refs
- Hashchain helper:
  - deterministic hashing rule for events

### Acceptance
- Hashes match Python reference for the same canonical JSON.
- Artifact store round-trip tests.

## Phase R1 — Schemas + Validation (lab-schemas)

### Deliverables
- Embed the JSON schemas from `schemas/` into the binary.
- `lab schema-validate --schema <name> --file <path>`

### Implementation Notes
- Use `include_str!` / `rust-embed` / `include_dir`.
- Use `jsonschema` crate (Draft 2020-12 support required).

### Acceptance
- Validate the same inputs as the Python implementation.

## Phase R2 — Hook Stream Validation (lab-hooks)

### Deliverables
- Parse `harness_manifest.json` (required for `cli_events`, `otel`, `sdk_*`).
- Validate hook events JSONL against schema + cross-event invariants:
  - `seq` monotonic increasing
  - step boundaries (`agent_step_start/end`)
  - `control_ack` after each `agent_step_end` and before next `agent_step_start`
  - stop means no further step starts
  - causal events include `step_index` when steps exist
  - optional header must match manifest

### CLI
- `lab hooks-validate --manifest <path> --events <path>`

### Acceptance
- Reproduce Python validator behavior on the same fixtures.

## Phase R3 — Provenance + Publish Bundles (lab-provenance)

### Deliverables
- `attestation.json` writer:
  - resolved spec digest
  - events hashchain heads
  - grades summary
  - harness identity (source/exec digests when available)
  - trace ingestion mode
  - optional SBOM reference
- Debug bundle builder:
  - zip of key artifacts
- `lab publish --run-dir <dir> [--out <zip>]`

### Acceptance
- Bundle contains the expected files.
- Attestation passes JSON schema validation.

## Phase R4 — Local Runner (lab-runner, no containers)

### Goal
Replace the Python “local best-effort runner” with a Rust one, preserving behavior:
- create run directory
- iterate tasks × variant-plan entries × reps
- write trial input
- run harness command
- validate trial output
- run analysis/report by invoking Python (initially)

### Deliverables
- `lab init` scaffolding (optional in Rust track; can remain in Python for a while)
- `lab run <experiment.yaml>` (local runner)
- `lab replay <trial_id>` (re-run harness with stored input)
- `lab fork --from <trial_id> --at <selector> --set k=v` (best-effort)

### Implementation Notes
- YAML parsing: `serde_yaml`
- JSON: `serde_json`
- Process spawn: `std::process::Command`
- Deterministically resolve relative command path args to absolute based on experiment directory.
- Provide env vars:
  - `AGENTLAB_CONTROL_PATH`
  - `AGENTLAB_CONTROL_MODE`
  - `AGENTLAB_HARNESS_ROOT`
- CWD set to the trial directory.

### Acceptance
- End-to-end “demo harness” experiment completes and generates a report.

## Phase R5 — Container Runner + Profiles (Linux-first)

### Goal
Implement the real enforcement boundary:
- read-only root
- explicit writable surfaces
- network modes: `none|full|allowlist_enforced` (Linux only for allowlist)

### Deliverables
- Docker/OCI runner (start with Docker)
- Mount surfaces and enforce path constraints
- Network enforcement:
  - `none`: `--network=none`
  - `allowlist_enforced`: netns+iptables or sidecar proxy with bypass blocked
  - mandatory egress self-test artifact

### Acceptance
- If allowlist is requested but not enforced: fail early.

## Phase R6 — OTel Receiver (Optional)

### Goal
Provide a local OTLP endpoint and record whether spans were received.

### Deliverables
- Start OTLP HTTP receiver on loopback.
- Inject env vars into harness.
- Record trace ingestion manifest.

## Migration Strategy
- Keep schemas in `schemas/` as the versioned contract.
- Rust embeds schemas at build time.
- Python analysis/report can remain for a while and be invoked from Rust.
- Replace one command at a time:
  1. schema-validate/hooks-validate/publish
  2. attestation/debug bundle
  3. local run/replay/fork
  4. container run

## Why This Helps (Downstream)
- Reliable distribution (`lab` always exists, no uv/pip PATH issues).
- Linux enforcement becomes real (allowlist_enforced, profiles).
- Faster runs and lower “environment drift.”
- Clear separation:
  - Rust: orchestration + enforcement + provenance
  - Harness: BYO CLI + evidence emission
  - Analysis: Python or Rust later
